import type { Packed } from '@fuxingloh/origami-json';
import type { SubscriptionConfig } from '@fuxingloh/origami-program/types';
import { Generated, Insertable, Kysely, PostgresDialect, Selectable, Updateable } from 'kysely';
import { Pool, types } from 'pg';

types.setTypeParser(types.builtins.NUMERIC, (value) => {
  return BigInt(value);
});

export interface Database {
  Program: ProgramTable;
  ProgramSubscription: ProgramSubscriptionTable;
  Subscription: SubscriptionTable;
  SubscriptionStream: SubscriptionStreamTable;
  SubscriptionJob: SubscriptionJobTable;
}

export interface ProgramTable {
  /**
   * Owner of the program, a top-level object are owned by an entity resolved by IAM middleware.
   */
  owner: string;
  programId: Generated<string>;
  version: 'v1';
  /**
   * We store both the code on Program and Subscription.
   * Storing it here is for easier querying and listing of programs.
   */
  code: string;
  status: 'published' | 'started' | 'stopped' | 'destroying';
  createdAt: Generated<Date>;
}

export interface ProgramSubscriptionTable {
  programSubscriptionId: Generated<string>;
  programId: string;
  subscriptionId: string;
}

export interface SubscriptionTable {
  /**
   * Signature of the subscription, generated by combing version, config and code.
   */
  subscriptionId: string;
  usi: string;
  version: 'v1';
  code: string;
  config: SubscriptionConfig;
  createdAt: Generated<Date>;
}

export interface SubscriptionStreamTable {
  subscriptionId: string;
  hash: string;
  n: number;
  group: string | null;
  sort: string | null;
  sequence: bigint;
  header: Packed;
  data: Packed | null;
}

export interface SubscriptionJobTable {
  // TODO(?): This is not a very well-designed table.
  //   Waiting for revision improvement to jobs prioritization and scheduling.
  jobId: Generated<string>;
  subscriptionId: string;
  status: 'running' | 'completed' | 'errored' | 'unknown';
  updatedAt: Generated<Date>;
  startedAt: Generated<Date>;
  stoppedAt: Date | null;
}

export type Program = Selectable<ProgramTable>;
export type NewProgram = Insertable<ProgramTable>;
export type UpdateProgram = Updateable<ProgramTable>;

export type ProgramSubscription = Selectable<ProgramSubscriptionTable>;
export type NewProgramSubscription = Insertable<ProgramSubscriptionTable>;
export type UpdateProgramSubscription = Updateable<ProgramSubscriptionTable>;

export type Subscription = Selectable<SubscriptionTable>;
export type NewSubscription = Insertable<SubscriptionTable>;
export type UpdateSubscription = Updateable<SubscriptionTable>;

export type SubscriptionStream = Selectable<SubscriptionStreamTable>;
export type NewSubscriptionStream = Insertable<SubscriptionStreamTable>;
export type UpdateSubscriptionStream = Updateable<SubscriptionStreamTable>;

export type SubscriptionJob = Selectable<SubscriptionJobTable>;
export type NewSubscriptionJob = Insertable<SubscriptionJobTable>;
export type UpdateSubscriptionJob = Updateable<SubscriptionJobTable>;

export type Db = Kysely<Database>;

export function initDb(config?: {
  database?: string;
  host?: string;
  port?: number;
  user?: string;
  password?: string;
}): Db {
  const dialect = new PostgresDialect({
    pool: new Pool({
      database: config?.database ?? process.env.IMAGIRO_DATA_PG_DATABASE ?? 'imagiro-data',
      host: config?.host ?? process.env.IMAGIRO_DATA_PG_HOST,
      port: config?.port ?? parseInt(process.env.IMAGIRO_DATA_PG_PORT || '5432'),
      user: config?.user ?? process.env.IMAGIRO_DATA_PG_USER,
      password: config?.password ?? process.env.IMAGIRO_DATA_PG_PASSWORD,
    }),
  });
  return new Kysely<Database>({
    dialect: dialect,
  });
}

export { sql as raw } from 'kysely';
export * from 'kysely/helpers/postgres';
